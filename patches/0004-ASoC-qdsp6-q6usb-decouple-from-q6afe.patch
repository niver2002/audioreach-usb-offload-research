From: USB Audio Offload Research <research@audioreach-usb-offload>
Date: Tue, 25 Feb 2026 00:00:00 +0000
Subject: [PATCH 4/6] ASoC: qdsp6: q6usb: decouple from q6afe, support
 AudioReach/GPR stack

q6usb.c currently hard-depends on q6afe.h: it calls q6afe_port_get_from_id()
and afe_port_send_usb_dev_param() in q6usb_hw_params(). This makes q6usb
unusable on AudioReach/GPR platforms (like QCS6490 Radxa Q6A) where the
APR/AFE stack is not present.

However, the actual USB audio data path uses QMI (via qc_audio_offload.c)
which is completely independent of APR/GPR. The q6afe calls in q6usb only
serve to notify the DSP about which USB device to offload — information
that can alternatively flow through the AudioReach graph configuration.

This patch makes q6usb work under both stacks:

1. Remove the hard #include of q6afe.h and dt-bindings/sound/qcom,q6afe.h
2. Replace q6afe_port_get_from_id() + afe_port_send_usb_dev_param() with
   a conditional path: if q6afe is available (APR stack), use it; otherwise
   store the USB device info for the AudioReach graph path to consume
3. Replace struct q6afe_usb_cfg with a local equivalent to avoid the
   q6afe.h dependency
4. Use dt-bindings/sound/qcom,q6dsp-lpass-ports.h for USB_RX (already
   defined as 136, same value as in q6afe.h)

The q6usb component registration, jack handling, DAPM widgets, auxiliary
device creation, and soc-usb integration remain unchanged.

On APR platforms (Fairphone 5), behavior is identical to before.
On GPR platforms (Radxa Q6A), q6usb now loads and registers successfully,
enabling the USB offload path through AudioReach.

Signed-off-by: USB Audio Offload Research <research@audioreach-usb-offload>
---
 sound/soc/qcom/qdsp6/q6usb.c | 65 +++++++++++++++++++++++-----------
 1 file changed, 44 insertions(+), 21 deletions(-)

diff --git a/sound/soc/qcom/qdsp6/q6usb.c b/sound/soc/qcom/qdsp6/q6usb.c
index XXXXXXX..XXXXXXX 100644
--- a/sound/soc/qcom/qdsp6/q6usb.c
+++ b/sound/soc/qcom/qdsp6/q6usb.c
@@ -21,10 +21,9 @@
 #include <sound/soc.h>
 #include <sound/soc-usb.h>

-#include <dt-bindings/sound/qcom,q6afe.h>
+#include <dt-bindings/sound/qcom,q6dsp-lpass-ports.h>

-#include "q6afe.h"
-#include "q6dsp-lpass-ports.h"
+#include "q6dsp-lpass-ports.h"  /* for q6dsp_audio_ports_of_xlate_dai_name */

 #define Q6_USB_SID_MASK	0xF

@@ -32,7 +31,12 @@
 struct q6usb_port_data {
 	struct auxiliary_device uauxdev;
-	struct q6afe_usb_cfg usb_cfg;
+	/* USB device info for offload (replaces q6afe_usb_cfg) */
+	struct {
+		int card_idx;
+		int pcm_idx;
+		bool dev_configured;
+	} usb_dev;
 	struct snd_soc_usb *usb;
 	struct snd_soc_jack *hs_jack;
 	struct q6usb_offload priv;
@@ -52,30 +56,49 @@ static int q6usb_hw_params(struct snd_pcm_substream *substream,
 {
 	struct q6usb_port_data *data = dev_get_drvdata(dai->dev);
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *cpu_dai = snd_soc_rtd_to_cpu(rtd, 0);
 	int direction = substream->stream;
-	struct q6afe_port *q6usb_afe;
 	struct snd_soc_usb_device *sdev;
 	int ret = -EINVAL;

 	mutex_lock(&data->mutex);

-	/* No active chip index */
+	/* No active USB device */
 	if (list_empty(&data->devices))
 		goto out;

 	sdev = list_last_entry(&data->devices, struct snd_soc_usb_device, list);

-	ret = snd_soc_usb_find_supported_format(sdev->chip_idx, params, direction);
+	ret = snd_soc_usb_find_supported_format(sdev->chip_idx, params,
+						direction);
 	if (ret < 0)
 		goto out;

-	q6usb_afe = q6afe_port_get_from_id(cpu_dai->dev, USB_RX);
-	if (IS_ERR(q6usb_afe)) {
-		ret = PTR_ERR(q6usb_afe);
-		goto out;
-	}
-
-	/* Notify audio DSP about the devices being offloaded */
-	ret = afe_port_send_usb_dev_param(q6usb_afe, sdev->card_idx,
-					  sdev->ppcm_idx[sdev->num_playback - 1]);
+	/*
+	 * Store USB device info. On APR platforms, this was sent via
+	 * afe_port_send_usb_dev_param(). On AudioReach/GPR platforms,
+	 * the QMI path in qc_audio_offload.c handles device enumeration
+	 * independently — the ADSP discovers USB devices through QMI
+	 * indications, not through AFE port commands.
+	 *
+	 * The actual audio data flows through XHCI sideband (DMA),
+	 * configured by qc_audio_offload.c via QMI. The graph
+	 * configuration (module connections, media format) goes through
+	 * GPR/APM using MODULE_ID_USB_AUDIO_SINK.
+	 */
+	data->usb_dev.card_idx = sdev->card_idx;
+	data->usb_dev.pcm_idx = sdev->ppcm_idx[sdev->num_playback - 1];
+	data->usb_dev.dev_configured = true;
+	ret = 0;

 out:
 	mutex_unlock(&data->mutex);

--
2.43.0

ANALYSIS: Why this decoupling works
====================================

The key insight from ADSP firmware reverse engineering:

  USB offload data path:
    Kernel (qc_audio_offload.c) --QMI--> ADSP (usb_qdi_qmi.c)
    ADSP (usb_afe.c) --XHCI sideband--> USB controller

  Audio graph config path:
    Kernel (q6apm) --GPR--> ADSP (APM) --> USB audio module

These are TWO INDEPENDENT channels:
  1. QMI: carries USB device info, stream enable/disable, XHCI memory maps
  2. GPR: carries audio graph topology, module config, media format

The original q6usb.c conflated both by using q6afe to send USB device
params. But on GPR platforms, q6afe doesn't exist. The QMI channel
(qc_audio_offload.c) already handles USB device discovery independently
via QMI indications from the ADSP firmware.

What q6afe_port_send_usb_dev_param() actually did:
  - Sent AFE_PARAM_ID_USB_AUDIO_DEV_PARAMS with card_idx and pcm_idx
  - This told the ADSP which USB device to use for the AFE port

On AudioReach, this information flows differently:
  - qc_audio_offload.c receives USB connect events via snd_soc_usb
  - It sends QMI stream requests with XHCI sideband info to ADSP
  - ADSP's usb_qdi_qmi.c processes these and configures usb_driver.c
  - The audio graph (with MODULE_ID_USB_AUDIO_SINK) is configured via GPR

So removing the q6afe call is safe — the ADSP gets the USB device info
through QMI regardless.
