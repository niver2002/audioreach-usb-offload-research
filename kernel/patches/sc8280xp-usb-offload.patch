From: USB Audio Offload Research <research@example.com>
Subject: [PATCH] ASoC: qcom: sc8280xp: Add USB audio offload support

Add USB audio offload jack handling to the sc8280xp machine driver,
enabling USB audio offload on boards using this driver (including
QCS6490-RB3Gen2 / Radxa Q6A).

The implementation follows the same pattern as sm8250.c which already
has USB offload support for the Fairphone 5 (QCM6490, same SoC).

Changes:
  - Include usb_offload_utils.h
  - Add usb_offload_jack and usb_offload_jack_setup to private data
  - Handle USB_RX DAI in sc8280xp_snd_init()
  - Add sc8280xp_snd_exit() for USB jack cleanup
  - Register exit callback in sc8280xp_add_be_ops()

Kconfig note: SND_SOC_SC8280XP should add:
  depends on SND_SOC_QCOM_OFFLOAD_UTILS || !SND_SOC_QCOM_OFFLOAD_UTILS

Signed-off-by: USB Audio Offload Research <research@example.com>
---
 sound/soc/qcom/Kconfig    |  1 +
 sound/soc/qcom/sc8280xp.c | 25 ++++++++++++++++++++++++-
 2 files changed, 25 insertions(+), 1 deletion(-)

diff --git a/sound/soc/qcom/Kconfig b/sound/soc/qcom/Kconfig
index XXXXXXX..XXXXXXX 100644
--- a/sound/soc/qcom/Kconfig
+++ b/sound/soc/qcom/Kconfig
@@ -XXX,6 +XXX,7 @@ config SND_SOC_SC8280XP
 	tristate "SoC Machine driver for SC8280XP boards"
 	depends on QCOM_APR && SOUNDWIRE
 	depends on COMMON_CLK
+	depends on SND_SOC_QCOM_OFFLOAD_UTILS || !SND_SOC_QCOM_OFFLOAD_UTILS
 	select SND_SOC_QDSP6
 	select SND_SOC_QCOM_COMMON
 	select SND_SOC_QCOM_SDW
diff --git a/sound/soc/qcom/sc8280xp.c b/sound/soc/qcom/sc8280xp.c
index XXXXXXX..XXXXXXX 100644
--- a/sound/soc/qcom/sc8280xp.c
+++ b/sound/soc/qcom/sc8280xp.c
@@ -13,6 +13,7 @@
 #include <linux/input-event-codes.h>
 #include "qdsp6/q6afe.h"
 #include "common.h"
+#include "usb_offload_utils.h"
 #include "sdw.h"

 struct sc8280xp_snd_data {
@@ -20,6 +21,8 @@ struct sc8280xp_snd_data {
 	struct snd_soc_card *card;
 	struct snd_soc_jack jack;
 	struct snd_soc_jack dp_jack[8];
+	struct snd_soc_jack usb_offload_jack;
+	bool usb_offload_jack_setup;
 	bool jack_setup;
 };

@@ -55,6 +58,10 @@ static int sc8280xp_snd_init(struct snd_soc_pcm_runtime *rtd)
 		dp_jack = &data->dp_jack[dp_pcm_id];
 		break;
+	case USB_RX:
+		return qcom_snd_usb_offload_jack_setup(rtd,
+						       &data->usb_offload_jack,
+						       &data->usb_offload_jack_setup);
 	default:
 		break;
 	}
@@ -65,6 +72,17 @@ static int sc8280xp_snd_init(struct snd_soc_pcm_runtime *rtd)
 	return qcom_snd_wcd_jack_setup(rtd, &data->jack, &data->jack_setup);
 }

+static void sc8280xp_snd_exit(struct snd_soc_pcm_runtime *rtd)
+{
+	struct sc8280xp_snd_data *data = snd_soc_card_get_drvdata(rtd->card);
+	struct snd_soc_dai *cpu_dai = snd_soc_rtd_to_cpu(rtd, 0);
+
+	if (cpu_dai->id == USB_RX)
+		qcom_snd_usb_offload_jack_remove(rtd,
+						 &data->usb_offload_jack_setup);
+}
+
 static int sc8280xp_be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,
 				     struct snd_pcm_hw_params *params)
 {
@@ -126,6 +144,7 @@ static void sc8280xp_add_be_ops(struct snd_soc_card *card)
 	for_each_card_prelinks(card, i, link) {
 		if (link->no_pcm == 1) {
 			link->init = sc8280xp_snd_init;
+			link->exit = sc8280xp_snd_exit;
 			link->be_hw_params_fixup = sc8280xp_be_hw_params_fixup;
 			link->ops = &sc8280xp_be_ops;
 		}
--
2.43.0
